# Regras de Desenvolvimento - Padrões de Projeto

## Princípios Fundamentais

### SOLID
Sempre aplique os princípios SOLID em todo o código:

- **Single Responsibility Principle (SRP)**: Cada classe/função deve ter uma única responsabilidade
- **Open/Closed Principle (OCP)**: Abra para extensão, feche para modificação
- **Liskov Substitution Principle (LSP)**: Objetos derivados devem ser substituíveis por seus tipos base
- **Interface Segregation Principle (ISP)**: Interfaces específicas são melhores que uma interface geral
- **Dependency Inversion Principle (DIP)**: Dependa de abstrações, não de implementações concretas

### Domain-Driven Design (DDD)
- Organize o código em camadas: Domain, Application, Infrastructure, Presentation
- Use entidades, value objects, agregados e serviços de domínio
- Mantenha a lógica de negócio no domínio, não em camadas de infraestrutura
- Defina bounded contexts claros para diferentes partes do sistema

### Orientação a Objetos
- **SEMPRE priorize orientação a objetos** quando possível
- Use classes e interfaces para modelar o domínio
- Encapsule dados e comportamentos relacionados
- Aplique herança e polimorfismo quando apropriado
- Evite funções soltas quando um objeto seria mais apropriado

## Diretrizes de Implementação

### Estrutura de Código
- Organize classes e módulos por responsabilidade
- Use injeção de dependências para desacoplar componentes
- Prefira composição sobre herança quando possível
- Mantenha métodos pequenos e focados (Single Responsibility)

### Nomenclatura
- Use nomes descritivos que expressem a intenção
- Classes devem ser substantivos (ex: `LeadService`, `UserRepository`)
- Métodos devem ser verbos (ex: `createLead()`, `validateEmail()`)
- Interfaces devem começar com `I` ou terminar com `able` (ex: `ILeadRepository` ou `Validatable`)

### Abstrações
- Crie interfaces para contratos entre camadas
- Use abstrações para facilitar testes e manutenção
- Evite acoplamento direto com implementações concretas

### Testabilidade
- Escreva código testável desde o início
- Use injeção de dependências para facilitar mocks
- Separe lógica de negócio de frameworks e bibliotecas externas

### Gerenciamento de Dependências
- **SEMPRE use yarn** para instalar, atualizar ou remover pacotes
- **NUNCA use npm** neste projeto
- Use `yarn add` ao invés de `npm install`
- Use `yarn remove` ao invés de `npm uninstall`
- Use `yarn` ao invés de `npm install` para instalar dependências do projeto
- O projeto possui `yarn.lock` e deve ser mantido atualizado

### Comentários no Código
- **NUNCA escreva comentários no código**
- O código deve ser autoexplicativo através de nomes descritivos e estrutura clara
- Se o código precisa de comentário, refatore-o para ser mais claro
- Use nomes de variáveis, funções e classes que expressem claramente sua intenção
- A única exceção são comentários JSDoc/TSDoc para documentação de APIs públicas quando necessário para ferramentas de geração de documentação

## Exemplos de Boas Práticas

### ✅ BOM - Usando OOP e SOLID
```typescript
interface ILeadRepository {
  save(lead: Lead): Promise<void>;
  findById(id: string): Promise<Lead | null>;
}

class Lead {
  constructor(
    private id: string,
    private name: string,
    private email: string
  ) {}

  validate(): boolean {
    return this.name.length > 0 && this.isValidEmail(this.email);
  }

  private isValidEmail(email: string): boolean {
    return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
  }
}

class LeadService {
  constructor(private repository: ILeadRepository) {}

  async createLead(data: CreateLeadDTO): Promise<Lead> {
    const lead = new Lead(data.id, data.name, data.email);
    
    if (!lead.validate()) {
      throw new Error('Lead inválido');
    }
    
    await this.repository.save(lead);
    return lead;
  }
}
```

### ❌ RUIM - Sem OOP e SOLID
```typescript
function createLead(id: string, name: string, email: string) {
  if (name.length === 0) return null;
  if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) return null;
  
  supabase.from('leads').insert({ id, name, email });
}
```

## Quando Aplicar

- **Sempre** ao criar novas funcionalidades
- **Sempre** ao refatorar código existente
- **Sempre** ao revisar código de outros desenvolvedores
- Priorize OOP especialmente em:
  - Lógica de negócio complexa
  - Entidades de domínio
  - Serviços e repositórios
  - Casos de uso da aplicação

## Exceções

- Componentes React podem usar hooks e funções quando apropriado, mas ainda devem seguir SRP
- Utilitários simples podem ser funções puras
- Quando a complexidade não justifica OOP, use funções, mas mantenha SOLID

