# Regras de Desenvolvimento - Padrões de Projeto

## Princípios Fundamentais

### SOLID
Sempre aplique os princípios SOLID em todo o código:

- **Single Responsibility Principle (SRP)**: Cada classe/função deve ter uma única responsabilidade
- **Open/Closed Principle (OCP)**: Abra para extensão, feche para modificação
- **Liskov Substitution Principle (LSP)**: Objetos derivados devem ser substituíveis por seus tipos base
- **Interface Segregation Principle (ISP)**: Interfaces específicas são melhores que uma interface geral
- **Dependency Inversion Principle (DIP)**: Dependa de abstrações, não de implementações concretas

### Domain-Driven Design (DDD)
- Organize o código em camadas: Domain, Application, Infrastructure, Presentation
- Use entidades, value objects, agregados e serviços de domínio
- Mantenha a lógica de negócio no domínio, não em camadas de infraestrutura
- Defina bounded contexts claros para diferentes partes do sistema

### Orientação a Objetos
- **SEMPRE priorize orientação a objetos** quando possível
- Use classes e interfaces para modelar o domínio
- Encapsule dados e comportamentos relacionados
- Aplique herança e polimorfismo quando apropriado
- Evite funções soltas quando um objeto seria mais apropriado

## Diretrizes de Implementação

### Estrutura de Código
- Organize classes e módulos por responsabilidade
- Use injeção de dependências para desacoplar componentes
- Prefira composição sobre herança quando possível
- Mantenha métodos pequenos e focados (Single Responsibility)

### Nomenclatura
- Use nomes descritivos que expressem a intenção
- Classes devem ser substantivos (ex: `LeadService`, `UserRepository`)
- Métodos devem ser verbos (ex: `createLead()`, `validateEmail()`)
- Interfaces devem começar com `I` ou terminar com `able` (ex: `ILeadRepository` ou `Validatable`)

### Abstrações
- Crie interfaces para contratos entre camadas
- Use abstrações para facilitar testes e manutenção
- Evite acoplamento direto com implementações concretas

### Testabilidade
- Escreva código testável desde o início
- Use injeção de dependências para facilitar mocks
- Separe lógica de negócio de frameworks e bibliotecas externas

### Gerenciamento de Dependências
- **SEMPRE use yarn** para instalar, atualizar ou remover pacotes
- **NUNCA use npm** neste projeto
- Use `yarn add` ao invés de `npm install`
- Use `yarn remove` ao invés de `npm uninstall`
- Use `yarn` ao invés de `npm install` para instalar dependências do projeto
- O projeto possui `yarn.lock` e deve ser mantido atualizado

### Comentários no Código
- **NUNCA escreva comentários no código**
- O código deve ser autoexplicativo através de nomes descritivos e estrutura clara
- Se o código precisa de comentário, refatore-o para ser mais claro
- Use nomes de variáveis, funções e classes que expressem claramente sua intenção
- A única exceção são comentários JSDoc/TSDoc para documentação de APIs públicas quando necessário para ferramentas de geração de documentação

## Exemplos de Boas Práticas

### ✅ BOM - Usando OOP e SOLID
```typescript
interface ILeadRepository {
  save(lead: Lead): Promise<void>;
  findById(id: string): Promise<Lead | null>;
}

class Lead {
  constructor(
    private id: string,
    private name: string,
    private email: string
  ) {}

  validate(): boolean {
    return this.name.length > 0 && this.isValidEmail(this.email);
  }

  private isValidEmail(email: string): boolean {
    return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
  }
}

class LeadService {
  constructor(private repository: ILeadRepository) {}

  async createLead(data: CreateLeadDTO): Promise<Lead> {
    const lead = new Lead(data.id, data.name, data.email);
    
    if (!lead.validate()) {
      throw new Error('Lead inválido');
    }
    
    await this.repository.save(lead);
    return lead;
  }
}
```

### ❌ RUIM - Sem OOP e SOLID
```typescript
function createLead(id: string, name: string, email: string) {
  if (name.length === 0) return null;
  if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) return null;
  
  supabase.from('leads').insert({ id, name, email });
}
```

## Quando Aplicar

- **Sempre** ao criar novas funcionalidades
- **Sempre** ao refatorar código existente
- **Sempre** ao revisar código de outros desenvolvedores
- Priorize OOP especialmente em:
  - Lógica de negócio complexa
  - Entidades de domínio
  - Serviços e repositórios
  - Casos de uso da aplicação

## Exceções

- Componentes React podem usar hooks e funções quando apropriado, mas ainda devem seguir SRP
- Utilitários simples podem ser funções puras
- Quando a complexidade não justifica OOP, use funções, mas mantenha SOLID

## Atualização Automática de Documentação de Prompts

### Regra de Atualização do PROMPTS_AI_AGENTE.md

**SEMPRE que houver alterações em agentes ou componentes, atualize o arquivo `PROMPTS_AI_AGENTE.md`:**

1. **Quando atualizar:**
   - Ao modificar campos de configuração de agentes (campos em `ai_interaction_settings`)
   - Ao adicionar, remover ou modificar componentes (tabela `components`)
   - Ao alterar parâmetros ou comportamento de tools (especialmente tools com `identifier`)
   - Ao modificar a estrutura do payload enviado para o n8n
   - Ao adicionar novos campos de personalidade, estilo ou comportamento do agente

2. **O que atualizar:**
   - Seção "Estrutura do Payload Recebido" - se novos campos forem adicionados
   - Seção "Prompt de Sistema" - se novos campos de configuração forem adicionados
   - Seção "Habilidades e Componentes Disponíveis" - se componentes forem modificados
   - Seção "Regras de Uso dos Componentes" - se comportamento de componentes mudar
   - Seção "Tools Disponíveis no n8n" - se novas tools forem adicionadas ou parâmetros modificados
   - Seção "Template de Geração Dinâmica" - se variáveis do template mudarem

3. **Como atualizar:**
   - Mantenha o formato de variáveis do n8n: `{{ $json.payload.* }}`
   - Adicione notas explicativas quando necessário para processamento de arrays ou objetos complexos
   - Inclua exemplos de uso para novas funcionalidades
   - Documente todos os parâmetros obrigatórios e opcionais de tools
   - Mantenha a consistência com a estrutura atual do documento

4. **Arquivos relacionados que podem indicar necessidade de atualização:**
   - `src/services/agents/AgentDomain.ts` - Campos de agente
   - `src/services/components/ComponentConfig.ts` - Configurações de componentes
   - `src/services/YgdrasilChatService.ts` - Estrutura do payload
   - `supabase/functions/evolution-webhook/index.ts` - Payload enviado ao n8n
   - `src/pages/Playground.tsx` - Payload usado no playground
   - Migrations que alteram tabelas `ai_interaction_settings` ou `components`

5. **Verificação:**
   - Sempre verifique se o arquivo `PROMPTS_AI_AGENTE.md` está sincronizado após mudanças
   - Confirme que todas as variáveis estão no formato correto do n8n
   - Valide que exemplos e documentação estão atualizados

